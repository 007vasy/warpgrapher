<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Warpgrapher Book (v0.2.0)</title>
        
        <meta name="robots" content="noindex" />
        
        


        <!-- Custom HTML head -->
        


        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        
        <link rel="stylesheet" href="fonts/fonts.css">
        

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="warpgrapher/intro.html"><strong aria-hidden="true">1.</strong> Warpgrapher</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="warpgrapher/quickstart.html"><strong aria-hidden="true">1.1.</strong> Quickstart</a></li><li class="chapter-item expanded "><a href=".warpgrapher/databases.html"><strong aria-hidden="true">1.2.</strong> Databases</a></li><li class="chapter-item expanded "><a href="warpgrapher/config.html"><strong aria-hidden="true">1.3.</strong> Config</a></li></ol></li><li class="chapter-item expanded "><a href="api/intro.html"><strong aria-hidden="true">2.</strong> CRUD API</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="api/node_read.html"><strong aria-hidden="true">2.1.</strong> Node Read</a></li><li class="chapter-item expanded "><a href="api/node_create.html"><strong aria-hidden="true">2.2.</strong> Node Create</a></li><li class="chapter-item expanded "><a href="api/node_update.html"><strong aria-hidden="true">2.3.</strong> Node Update</a></li><li class="chapter-item expanded "><a href="api/node_delete.html"><strong aria-hidden="true">2.4.</strong> Node Update</a></li><li class="chapter-item expanded "><a href="api/rel_read.html"><strong aria-hidden="true">2.5.</strong> Relationship Read</a></li><li class="chapter-item expanded "><a href="api/rel_create.html"><strong aria-hidden="true">2.6.</strong> Relationship Create</a></li><li class="chapter-item expanded "><a href="api/rel_update.html"><strong aria-hidden="true">2.7.</strong> Relationship Update</a></li><li class="chapter-item expanded "><a href="api/rel_delete.html"><strong aria-hidden="true">2.8.</strong> Relationship Delete</a></li></ol></li><li class="chapter-item expanded "><a href="engine/intro.html"><strong aria-hidden="true">3.</strong> Engine Features</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="engine/endpoints_static.html"><strong aria-hidden="true">3.1.</strong> Static Endpoints</a></li><li class="chapter-item expanded "><a href="engine/endpoints_defined.html"><strong aria-hidden="true">3.2.</strong> Defined Endpoints</a></li><li class="chapter-item expanded "><a href="engine/dynamic_props.html"><strong aria-hidden="true">3.3.</strong> Dynamic Props</a></li><li class="chapter-item expanded "><a href="engine/dynamic_rels.html"><strong aria-hidden="true">3.4.</strong> Dynamic Relationships</a></li><li class="chapter-item expanded "><a href="engine/context_global.html"><strong aria-hidden="true">3.5.</strong> Global Context</a></li><li class="chapter-item expanded "><a href="engine/context_request.html"><strong aria-hidden="true">3.6.</strong> Request Context</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                        
                    </div>

                    <h1 class="menu-title">Warpgrapher Book (v0.2.0)</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1><a class="header" href="#warpgrapher" id="warpgrapher">Warpgrapher</a></h1>
<p>Warpgrapher is framework for developing graph-based API services. Describe the 
data model for which you want to run a web service. Wargrapher automatically 
generates a GraphQL schema from the data model, as well as a set of resolvers 
for basic reate, read, update, and delete (CRUD) operations on that data.</p>
<p>If you need more more sophisticated, custom queries and endpoints, you can
supply your own custom resolvers. Warpgrapher will automatically generate the
GraphQL configuration and invoke your custom resolvers when appropriate.</p>
<p>The project is currently in development. Prior to reaching v1.0.0:</p>
<ol>
<li>Minor versions represent breaking changes.</li>
<li>Patch versions represent fixes and features.</li>
<li>There are no deprecation warnings between releases.</li>
</ol>
<h1><a class="header" href="#quickstart" id="quickstart">Quickstart</a></h1>
<p>This guide will walk you through creating a brand new project using the Warpgrapher engine served over HTTP using actix-web. The back-end graph database in this example is Neo4J. </p>
<h2><a class="header" href="#dependencies" id="dependencies">Dependencies</a></h2>
<p>Add warpgrapher to your project config:</p>
<p><code>cargo.toml</code></p>
<pre><code class="language-toml">[dependencies]
actix = &quot;0.9.0&quot;
actix-web = &quot;2.0.0&quot;
warpgrapher = { version = &quot;0.2.0&quot;, features = [&quot;neo4j&quot;] }
</code></pre>
<h2><a class="header" href="#config" id="config">Config</a></h2>
<p>Create a warpgrapher config containing your application's data model. The next section explains the model in more details. </p>
<p><code>src/config.yml</code></p>
<pre><code class="language-yml">version: 1
model:

  # User
  - name: User
    props:
      - name: email
        type: String

  # Team
  - name: Team
    props:
      - name: name
        type: String
    rels:
      - name: users
        nodes: [User]
</code></pre>
<h2><a class="header" href="#code" id="code">Code</a></h2>
<p>Add the follow code to your project:</p>
<p><code>src/main.rs</code></p>
<pre><pre class="playground"><code class="language-rust">use actix::System;
use actix_http::error::Error;
use actix_web::web::{Data, Json};
use actix_web::{web, App, HttpResponse, HttpServer};
use std::collections::HashMap;
use warpgrapher::engine::database::neo4j::Neo4jEndpoint;
use warpgrapher::engine::database::DatabaseEndpoint;
use warpgrapher::{playground_source, Config, Engine, GraphQLRequest};

#[derive(Clone)]
struct ActixServerAppData {
    engine: Engine&lt;(), ()&gt;,
}

async fn graphql(
    data: Data&lt;ActixServerAppData&gt;,
    req: Json&lt;GraphQLRequest&gt;,
) -&gt; Result&lt;HttpResponse, Error&gt; {
    let metadata: HashMap&lt;String, String&gt; = HashMap::new();
    let resp = &amp;data.engine.execute(req.into_inner(), metadata);
    match resp {
        Ok(body) =&gt; Ok(HttpResponse::Ok()
            .content_type(&quot;application/json&quot;)
            .body(body.to_string())),
        Err(e) =&gt; Ok(HttpResponse::InternalServerError()
            .content_type(&quot;application/json&quot;)
            .body(e.to_string())),
    }
}

#[allow(clippy::ptr_arg)]
pub fn run_actix_server(engine: Engine&lt;(), ()&gt;) {
    let sys = System::new(&quot;warpgrapher-quickstart&quot;);
    let app_data = ActixServerAppData { engine };
    HttpServer::new(move || {
        App::new()
            .data(app_data.clone())
            .route(&quot;/graphql&quot;, web::post().to(graphql))
            .route(
                &quot;/graphiql&quot;,
                web::get().to(|| {
                    HttpResponse::Ok()
                        .content_type(&quot;text/html; charset=utf-8&quot;)
                        .body(playground_source(&amp;&quot;/graphql&quot;))
                }),
            )
    })
    .bind(&quot;127.0.0.1:5000&quot;)
    .expect(&quot;Failed to start server&quot;)
    .run();
    let _ = sys.run();
}

fn main() -&gt; Result&lt;(), Error&gt; {
    // load warpgrapher config
    let config =
        Config::from_file(&quot;./src/config.yml&quot;.to_string()).expect(&quot;Failed to load config file&quot;);

    // define database endpoint
    let db = Neo4jEndpoint::from_env().unwrap();

    // create warpgrapher engine
    let engine: Engine&lt;(), ()&gt; = Engine::new(config, db.pool().expect(&quot;Failed to build db pool&quot;))
        .build()
        .expect(&quot;Failed to build engine&quot;);

    // serve the warpgrapher engine on actix webserver
    println!(&quot;Warpgrapher quickstart app: http://localhost:5000/graphiql&quot;);
    run_actix_server(engine);

    Ok(())
}
</code></pre></pre>
<h2><a class="header" href="#run" id="run">Run</a></h2>
<p>Configure database settings:</p>
<pre><code class="language-bash">export WG_NEO4J_HOST=127.0.0.1
export WG_NEO4J_PORT=7687
export WG_NEO4J_USER=neo4j
export WG_NEO4J_PASS=*MY-DB-PASSWORD*
</code></pre>
<p>Start a 3.5 Neo4j database:</p>
<pre><code class="language-bash">docker run -e NEO4JAUTH=&quot;${WG_NEO4J_USER}:${WG_NEO4J_PASS}&quot; neo4j:4.1
</code></pre>
<p>Run quickstart app: </p>
<pre><code class="language-bash">cargo run
</code></pre>
<p>You should see the following output:</p>
<pre><code>Warpgrapher Quickstart App: https://localhost:5000/graphiql
</code></pre>
<p>Congrats! Now you have a running warpgrapher app. </p>
<h2><a class="header" href="#explore" id="explore">Explore</a></h2>
<p>Navigate to the displayed URL. You should see the GraphQL Playground which allows you to interact directly with the API. </p>
<h4><a class="header" href="#list-all-users" id="list-all-users">List all <code>Users</code></a></h4>
<p>First, list all <code>User</code> nodes in the database:</p>
<pre><code class="language-graphql">query {
  User {
    id
    email
  }
}
</code></pre>
<p>You should expect to see an empty list since the database is empty:</p>
<pre><code class="language-json">{
  &quot;data&quot;: {
    &quot;User&quot;: []
  }
}
</code></pre>
<h4><a class="header" href="#create-a-new-user" id="create-a-new-user">Create a new <code>User</code></a></h4>
<p>Next, create a new user:</p>
<pre><code>mutation {
  UserCreate(input: {
    email: &quot;user@example.com&quot;
  }) {
    id
    email
  }
}
</code></pre>
<p>The response should display the newly created user:</p>
<pre><code class="language-json">{
  &quot;data&quot;: {
    &quot;UserCreate&quot;: {
      &quot;email&quot;: &quot;user@example.com&quot;,
      &quot;id&quot;: &quot;0b2a6753-a5cf-46ea-b046-4935ea208950&quot;
    }
  }
}
</code></pre>
<p>(Your <code>id</code> will of course differ). </p>
<h4><a class="header" href="#create-a-new-team" id="create-a-new-team">Create a new <code>Team</code></a></h4>
<p>Now, create a <code>Team</code> node:</p>
<pre><code>mutation {
  TeamCreate(input: {
    name: &quot;Blue Team&quot;
  }) {
    id
    name
  }
}
</code></pre>
<p>Like before, you should see the newly created <code>Team</code> node:</p>
<pre><code class="language-json">{
  &quot;data&quot;: {
    &quot;TeamCreate&quot;: {
      &quot;id&quot;: &quot;d381a0f7-8a01-49e3-80ff-15ba01f3604f&quot;,
      &quot;name&quot;: &quot;Blue Team&quot;
    }
  }
}
</code></pre>
<h4><a class="header" href="#add-user-to-team" id="add-user-to-team">Add <code>User</code> to <code>Team</code></a></h4>
<p>GraphQL and Neo4j are all about relatinships. Create a <code>users</code> relationship between the <code>Team</code> and <code>User</code> nodes:</p>
<pre><code>mutation {
  TeamUsersCreate(input: {
    match: {
      name: &quot;Blue Team&quot;
    },
    create: {
      dst: {
        User: {
          EXISTING: {
            email: &quot;user@example.com&quot;
          }
        }
      }
    }
  }) {
    id
  }
}
</code></pre>
<pre><code class="language-json">{
  &quot;data&quot;: {
    &quot;TeamUsersCreate&quot;: {
      &quot;id&quot;: &quot;e5d5e19a-70bf-4d04-b32f-e61407100914&quot;,
    }
  }
}
</code></pre>
<h4><a class="header" href="#execute-nested-query" id="execute-nested-query">Execute nested query</a></h4>
<p>Finally, query the <code>Team</code> and all related <code>User</code> nodes under the <code>users</code> relationship:</p>
<pre><code>query {
  Team {
    id
    name
    users {
      dst {
        ... on User {
          id
          email
        }
      }
    }
  }
}
</code></pre>
<pre><code class="language-json">{
  &quot;data&quot;: {
    &quot;Team&quot;: [
      {
        &quot;id&quot;: &quot;cbd63d09-13b9-4199-b926-94716b2a547c&quot;,
        &quot;name&quot;: &quot;Blue Team&quot;,
        &quot;users&quot;: {
          &quot;dst&quot;: {
            &quot;email&quot;: &quot;user@example.com&quot;,
            &quot;id&quot;: &quot;78c71745-6362-49b2-8b6d-3e19de3f4efc&quot;
          }
        }
      }
    ]
  }
}
</code></pre>
<h1><a class="header" href="#databases" id="databases">Databases</a></h1>
<h1><a class="header" href="#warpgrapher-config" id="warpgrapher-config">Warpgrapher Config</a></h1>
<p>In the <a href="warpgrapher/">Quickstart</a> we demonstrated how to initialize a <code>Config</code> from a configurationf file read from file at run time. A Warpgrapher <code>Config</code> can also be generated programatically. The resulting configs from all the examples below are equivalent. </p>
<h3><a class="header" href="#text-config" id="text-config">Text Config</a></h3>
<pre><code class="language-yaml">version: 1
model:

  # User
  - name: User
    props:
      - name: username
        type: String
      - name: email
        type: String

  # Team
  - name: Team
    props:
      - name: teamname
        type: String
    rels:
      - name: members
        nodes: [User]
        list: true
</code></pre>
<h3><a class="header" href="#programmatic-config" id="programmatic-config">Programmatic Config</a></h3>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use warpgrapher::engine::config::{Config, Property, Relationship, Type};

let config = Config::new(
    1,
    vec![
        // User
        Type::new(
            &quot;User&quot;.to_string(),
            vec![
                Property::new(
                    &quot;username&quot;.to_string(),
                    &quot;String&quot;.to_string(),
                    false,
                    false,
                    None,
                    None,
                ),
                Property::new(
                    &quot;email&quot;.to_string(),
                    &quot;String&quot;.to_string(),
                    false,
                    false,
                    None,
                    None,
                ),
            ],
            Vec::new(),
            EndpointsFilter::all(),
        ),
        // Team
        Type::new(
            &quot;Team&quot;.to_string(),
            vec![Property::new(
                &quot;teamname&quot;.to_string(),
                &quot;String&quot;.to_string(),
                false,
                false,
                None,
                None,
            )],
            vec![Relationship::new(
                &quot;members&quot;.to_string(),
                true,
                vec![&quot;User&quot;.to_string()],
                Vec::new(),
                EndpointsFilter::default(),
                None,
            )],
            EndpointsFilter::all(),
        ),
    ],
    vec![],
);
<span class="boring">}
</span></code></pre></pre>
<h1><a class="header" href="#warpgrapher-crud-api" id="warpgrapher-crud-api">Warpgrapher CRUD API</a></h1>
<p>One of the primary features of Warpgrapher is the auto-generation of CRUD operations for all Types. This includes basic and advanced queries that support nested operations and graph traversals. </p>
<p>Warpgrapher automatically creates a set of CRUD (Create, Read, Update, Delete) operations for each Type and each rel in a Type. This page describes the format of those automatically generated GraphQL operations. </p>
<p>For for more details on general GraphQL syntax, see: https://graphql.org/learn/.</p>
<h1><a class="header" href="#node-read" id="node-read">Node Read</a></h1>
<ul>
<li><a href="api/node_read.html#read-all-nodes">Read All Nodes</a></li>
<li><a href="api/node_read.html#read-nodes-with-matching-props">Read nodes with matching props</a></li>
<li><a href="api/node_read.html#return-nodes-with-relationships-to-other-nodes-with-matching-props">Return nodes with relationships to other nodes with matching props</a></li>
</ul>
<h3><a class="header" href="#return-all-nodes" id="return-all-nodes">Return all nodes</a></h3>
<p>To return all <code>Project</code> nodes:</p>
<pre><code>query {
    Project {
        id
        name
        status
    }
}
</code></pre>
<h3><a class="header" href="#return-nodes-with-matching-props" id="return-nodes-with-matching-props">Return nodes with matching props</a></h3>
<p>To return all <code>Project</code> nodes with <code>status == &quot;ACTIVE&quot;</code>:</p>
<pre><code>query {
    Project(
        input: {
            status: &quot;ACTIVE&quot;
        }
    )
    {
        id
        name
    }
}
</code></pre>
<h3><a class="header" href="#return-nodes-with-relationships-to-other-nodes-with-matching-props" id="return-nodes-with-relationships-to-other-nodes-with-matching-props">Return nodes with relationships to other nodes with matching props</a></h3>
<p>To returns all <code>Project</code> nodes containing an <code>owner</code> relationship to a <code>User</code> node with <code>name=&quot;Halsey&quot;</code>:</p>
<pre><code>query {
    Project(
        input: {
            owner: {
                dst: {
                    User: {
                        name: &quot;Halsey&quot;
                    }
                }
            }
        }
    )
    { ... }
}
</code></pre>
<h1><a class="header" href="#node-create" id="node-create">Node Create</a></h1>
<ul>
<li><a href="api/node_create.html#create-node-with-no-relationships">Create node with no relationships</a></li>
<li><a href="api/node_create.html#create-node-with-relationship-to-a-new-node">Create node with relationship to a NEW node</a></li>
<li><a href="api/node_create.html#create-node-with-relationship-to-an-existing-node">Create node with relationship to an EXISTING node</a></li>
</ul>
<h3><a class="header" href="#create-node-with-no-relationships" id="create-node-with-no-relationships">Create node with no relationships</a></h3>
<p>To create a new <code>Project</code> node by itself:</p>
<pre><code>mutation {
    ProjectCreate(
        input: {
            name: &quot;Project 1&quot;,
            status: &quot;ACTIVE&quot;
        }
    )
    {
        id
        name
    }
}
</code></pre>
<p>Output:</p>
<pre><code class="language-json">{
  &quot;data&quot;: {
    &quot;ProjectCreate&quot;: {
      &quot;id&quot;: &quot;a55e1dae-a87f-4ca1-8724-b967a678b942&quot;,
      &quot;name&quot;: &quot;Project 1&quot;
    }
  }
}
</code></pre>
<h3><a class="header" href="#create-node-with-relationship-to-a-new-node" id="create-node-with-relationship-to-a-new-node">Create node with relationship to a <code>NEW</code> node</a></h3>
<p>To create a new <code>Project</code> node with an <code>owner</code> relationship to a new <code>User</code> node:</p>
<pre><code>mutation {
    ProjectCreate(
        input: {
            name: &quot;Project 2&quot;,
            status: &quot;ACTIVE&quot;,
            owner: {
                dst: {
                    User: {
                        $NEW: {
                            name: &quot;Smith&quot;
                        }
                    }
                }
            }
        }
    )
    { ... }
}
</code></pre>
<h3><a class="header" href="#create-node-with-relationship-to-an-existing-node" id="create-node-with-relationship-to-an-existing-node">Create node with relationship to an <code>EXISTING</code> node</a></h3>
<p>To create a new <code>Project</code> node with an <code>owner</code> relationship to an existing <code>User</code> node:</p>
<pre><code>mutation {
    ProjectCreate(
        input: {
            name: &quot;Project 3&quot;,
            status: &quot;ACTIVE&quot;,
            owner: {
                dst: {
                    User: {
                        $EXISTING: {
                            name: &quot;Oneill&quot;
                        }
                    }
                }
            }
        }
    )
    { ... }
}
</code></pre>
<h1><a class="header" href="#node-update" id="node-update">Node Update</a></h1>
<ul>
<li><a href="api/node_update.html#update-props-on-node-with-matching-props">Update props on node with matching props</a></li>
<li><a href="api/node_update.html#update-props-on-node-with-a-relationship-to-a-node-containing-matching-props">Update props on node with a relationship to a node containing matching props</a></li>
<li><a href="api/node_update.html#update-node-to-add-multi-node-relationships">Update node to add (multi-node) relationships</a></li>
</ul>
<h3><a class="header" href="#update-props-on-node-with-matching-props" id="update-props-on-node-with-matching-props">Update props on node with matching props</a></h3>
<p>To update the <code>status</code> of the <code>Project</code> node with <code>name == &quot;Project 2&quot;</code>:</p>
<pre><code>mutation {
    ProjectCreate(
        input: {
            $MATCH: {
                name: &quot;Project 2&quot;
            },
            $SET: {
                status: &quot;INACTIVE&quot;
            }
        }
    )
    { ... }
}
</code></pre>
<h3><a class="header" href="#update-props-on-node-with-a-relationship-to-a-node-containing-matching-props" id="update-props-on-node-with-a-relationship-to-a-node-containing-matching-props">Update props on node with a relationship to a node containing matching props</a></h3>
<p>To update the status of any <code>Project</code> nodes containing an <code>owner</code> relationship to the <code>User</code> with <code>name  == &quot;Smith&quot;</code>:</p>
<pre><code>mutation {
    ProjectCreate(
        input: {
            $MATCH: {
                owner: {
                    dst: {
                        User: {
                            name: &quot;Smith&quot;
                        }
                    }
                }
            },
            $SET: {
                status: &quot;INACTIVE&quot;
            }
        }
    )
    { ... }
}
</code></pre>
<h3><a class="header" href="#update-node-to-add-multi-node-relationships" id="update-node-to-add-multi-node-relationships">Update node to add <code>(multi-node)</code> relationships</a></h3>
<p>To update a specific <code>Project</code> node to add several <code>issue</code> relationships to new <code>Feature</code> and <code>Bug</code> nodes, call <code>ProjectUpdate</code> with:</p>
<pre><code>mutation {
    ProjectUpdate(
        input: {
            $MATCH: {
                id: &quot;&lt;ID&gt;&quot;
            },
            $SET: {
                issues: [
                    {
                        $ADD: {
                            dst: {
                                Feature: {
                                    $NEW: {
                                        name: &quot;Add login page&quot;
                                    }
                                }
                            }
                        }
                    },
                    {
                        $ADD: {
                            dst: {
                                Bug: {
                                    $NEW: {
                                        name: &quot;Fix auth bug&quot;
                                    }
                                }
                            }
                        }
                    }
                ]
            }
        }
    ) 
    { ... }
}
</code></pre>
<h1><a class="header" href="#node-delete" id="node-delete">Node Delete</a></h1>
<ul>
<li><a href="api/node_delete.html#delete-node-with-matching-props">Delete node with matching props</a></li>
</ul>
<h3><a class="header" href="#delete-node-with-matching-props" id="delete-node-with-matching-props">Delete node with matching props</a></h3>
<p>To delete <code>Project</code> nodes with status &quot;INACTIVE&quot;, call <code>ProjectDelete</code> with: </p>
<pre><code>mutation {
    ProjectDelete(
        input: {
            $MATCH: {
                status: &quot;INACTIVE&quot;
            },
            $DELETE: {
            }
        }
    )
    { ... }
}
</code></pre>
<h1><a class="header" href="#relationship-read" id="relationship-read">Relationship Read</a></h1>
<ul>
<li><a href="api/rel_read.html#find-relationships-by-src-node">Find relationships by src node</a></li>
<li><a href="api/rel_read.html#find-relationships-by-dst-node">Find relationships by dst node</a></li>
<li><a href="api/rel_read.html#find-relationships-by-rel-props">Find relationships by rel props</a></li>
</ul>
<h3><a class="header" href="#find-relationships-by-src-node" id="find-relationships-by-src-node">Find relationships by src node</a></h3>
<pre><code>query {
    ProjectIssues(input: {
        src: {
            Project: {
                name: &quot;Project 0&quot;
            }
        }
    })
    {
        id
    }
}
</code></pre>
<h3><a class="header" href="#find-relationships-by-dst-node" id="find-relationships-by-dst-node">Find relationships by dst node</a></h3>
<pre><code>query {
    ProjectIssues(input: {
        dst: {
            Feature: {
                name: &quot;Add new button&quot;
            }
        }
    })
    {...}
}
</code></pre>
<h3><a class="header" href="#find-relationships-by-rel-props" id="find-relationships-by-rel-props">Find relationships by rel props</a></h3>
<pre><code>query {
    ProjectOwner(input: {
        props: {
            since: &quot;2015&quot;
        }
    })
    {...}
}
</code></pre>
<h1><a class="header" href="#relationship-create" id="relationship-create">Relationship Create</a></h1>
<ul>
<li><a href="api/rel_create.html#create-relationship-between-pair-of-existing-nodes">Create relationship between pair of existing nodes</a></li>
<li><a href="api/rel_create.html#create-relationship-from-existing-node-to-new-node">Create relationship from existing node to new node</a></li>
</ul>
<h3><a class="header" href="#create-relationship-between-pair-of-existing-nodes" id="create-relationship-between-pair-of-existing-nodes">Create relationship between pair of existing nodes</a></h3>
<pre><code>mutation {
    ProjectOwnerCreate(input: {
        $MATCH: {
            name: &quot;Project0&quot;
        },
        $CREATE: {
            dst: {
                User: {
                    $EXISTING: {
                        name: &quot;Jane&quot;
                    }
                }
            }
        } 
    })
    {...}
}
</code></pre>
<h3><a class="header" href="#create-relationship-between-from-existing-node-to-new-node" id="create-relationship-between-from-existing-node-to-new-node">Create relationship between from existing node to new node</a></h3>
<pre><code>mutation {
    ProjectOwnerCreate(input: {
        $MATCH: {
            name: &quot;Project0&quot;
        },
        $CREATE: {
            dst: {
                User: {
                    $NEW: {
                        name: &quot;Joe&quot;
                    }
                }
            }
        } 
    })
    {...}
}
</code></pre>
<h1><a class="header" href="#relationship-update" id="relationship-update">Relationship Update</a></h1>
<ul>
<li><a href="api/rel_update.html#update-relationship-props">Update relationship props</a></li>
</ul>
<h3><a class="header" href="#update-relationships-props" id="update-relationships-props">Update relationships props</a></h3>
<pre><code>mutation {
    ProjectOwnerUpdate(input: {
        $MATCH: {
            props: {
                sin
            }
        }
    })
    {
        id
    }
}
</code></pre>
<h1><a class="header" href="#relationship-delete" id="relationship-delete">Relationship Delete</a></h1>
<ul>
<li><a href="api/rel_delete.html#delete-relationships">Delete relationships</a></li>
</ul>
<h3><a class="header" href="#delete-relationships" id="delete-relationships">Delete relationships</a></h3>
<pre><code>mutation {
    ProjectOwnerDelete(input: {
        $MATCH: {
            src: {
                Project: {
                    name: &quot;Project0&quot;
                }
            }
        }
    })
}
</code></pre>
<p>Output:</p>
<pre><code class="language-json">{
    &quot;data&quot;: {
        &quot;ProjectOwnerDelete&quot;: 1
    }
}
</code></pre>
<h1><a class="header" href="#engine-features" id="engine-features">Engine Features</a></h1>
<h1><a class="header" href="#static-endpoints" id="static-endpoints">Static Endpoints</a></h1>
<p>Warpgrapher includes built-in static endpoints that provide useful information or functionality. Built-in static endpoints names are preceded by <code>_</code>.</p>
<h2><a class="header" href="#version" id="version">Version</a></h2>
<p>If the <code>Engine</code> is built with an explicit version:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut server: Engine&lt;(), ()&gt; = Engine::new(config, db)
    .with_version(&quot;0.1.0&quot;.to_string())
    .build();
<span class="boring">}
</span></code></pre></pre>
<p>the version value can be accessed via the <code>_version</code> endpoint:</p>
<pre><code>query {
    _version
}
</code></pre>
<pre><code class="language-json">{
  &quot;data&quot;: {
    &quot;_version&quot;: &quot;0.1.0&quot;
  }
}
</code></pre>
<p>If the server is not configured with an explicit version, the <code>_version</code> endpoint will return <code>null</code>:</p>
<pre><code class="language-json">{
  &quot;data&quot;: {
    &quot;_version&quot;: null
  }
}
</code></pre>
<h1><a class="header" href="#defined-endpoints" id="defined-endpoints">Defined Endpoints</a></h1>
<p>In addition to the CRUD endpoints auto-generated for each type, a Warpgrapher app serve additional defined GraphQL endpoints (root queries/mutations).</p>
<h2><a class="header" href="#usage" id="usage">Usage</a></h2>
<h4><a class="header" href="#1-add-endpoints-to-config" id="1-add-endpoints-to-config">1. Add Endpoints to Config</a></h4>
<p>The following config specified no types in the <code>model</code> section (so no CRUD endpoints will be generated), but defines several endpoints of varying inputs and outputs. </p>
<pre><code class="language-yaml">version: 1
model:

  # Team
  - name: Team
    props:
    - name: name
      type: String
    - name: size
      type: Int

endpoints:

  # GetAppName
  - name: GetAppName
    class: Query
    input: null
    output:
      type: String

  # GetLargetTeam
  - name: GetLargestTeam
    class: Query
    input: null
    output:
      type: Team
</code></pre>
<h4><a class="header" href="#2-implement-endpoint-resolver-logic" id="2-implement-endpoint-resolver-logic">2. Implement endpoint resolver logic</a></h4>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::collections::HashMap;
use warpgrapher::engine::resolvers::{ResolverFacade, ExecutionResult};
use warpgrapher::value::Value;

// resolver that returns a Scalar (String)
fn resolve_getappname(
  context: ResolverFacade&lt;(), ()&gt;
) -&gt; ExecutionResult {

  facade.resolve_scalar(&quot;MyAppName&quot;)
}

// resolver that returns a Node (Team)
fn resolve_getlargestteam(
  facade: ResolverFacade&lt;(), ()&gt;
) -&gt; ExecutionResult {

  // query database to get team ...
  let mut hm = HashMap::new();
  hm.insert(&quot;name&quot;.to_string(), Value::String(&quot;Blue Team&quot;.to_string()));
  hm.insert(&quot;size&quot;.to_string(), Value::Int64(5));
  
  let largest_team_node = facade.create_node((&quot;Team&quot;, &amp;hm);

  context.resolve_node(&amp;larget_team_node)
}
<span class="boring">}
</span></code></pre></pre>
<h4><a class="header" href="#3-add-resolvers-when-building-engine" id="3-add-resolvers-when-building-engine">3. Add resolvers when building <code>Engine</code></a></h4>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use warpgrapher::Engine;

let mut resolvers = Resolvers&lt;(), ()&gt;::new();
resolvers.insert(&quot;GetAppName&quot;.to_string, Box::new(resolve_getappname));
resolvers.insert(&quot;GetLargestTeam&quot;.to_string, Box::new(resolve_getlargestteam));

let engine = Engine&lt;(), ()&gt;::new(config, db)
    .with_resolvers(resolvers)
    .build();
<span class="boring">}
</span></code></pre></pre>
<h4><a class="header" href="#4-call-defined-endpoints" id="4-call-defined-endpoints">4. Call Defined Endpoints</a></h4>
<pre><code>query {
  GetAppName
}
</code></pre>
<pre><code class="language-json">{
  &quot;data&quot;: {
    &quot;GetAppName&quot;: &quot;MyAppName&quot;
  }
}
</code></pre>
<pre><code>query {
  GetLargestTeam {
    id
    name
    size
  }
}
</code></pre>
<pre><code class="language-json">{
  &quot;data&quot;: {
    &quot;GetLargestTeam&quot;: {
      &quot;id&quot;: &quot;123456789012345670&quot;,
      &quot;name&quot;: &quot;Blue Team&quot;,
      &quot;size&quot;: 5
    }
  }
}
</code></pre>
<h1><a class="header" href="#dynamic-props" id="dynamic-props">Dynamic Props</a></h1>
<p>When Warpgrapher auto-generates a CRUD endpoint, the values of Node and Relationship properties are retreived from the database and returned in a query. In some cases, however, it may be necessary to perform real-time computations to derive the value of a prop. We call these type of properties &quot;dynamic properties&quot;, and Warpgrapher provides a mechanism to execute custom logic to resolve the value of the prop. </p>
<h2><a class="header" href="#usage-1" id="usage-1">Usage</a></h2>
<h4><a class="header" href="#1-mark-a-properties-as-dynamic-by-setting-the-resolver-field" id="1-mark-a-properties-as-dynamic-by-setting-the-resolver-field">1. Mark a properties as dynamic by setting the resolver field</a></h4>
<pre><code class="language-config">version: 1
model: 
 - name: Project
   props: 
    - name: points
      type: int
      resolver: project_points
</code></pre>
<h4><a class="header" href="#2-define-custom-logic-that-resolve-the-prop-value" id="2-define-custom-logic-that-resolve-the-prop-value">2. Define custom logic that resolve the prop value</a></h4>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn resolve_projectpoints(
    context: ResolverFacade&lt;AppGlobalContext, ()&gt;
) -&gt; ExecutionResult {

    // compute value ...
    let value = 
    
    facade.resolve_scalar(value)
}
<span class="boring">}
</span></code></pre></pre>
<h4><a class="header" href="#3-add-prop-resolver-when-building-engine" id="3-add-prop-resolver-when-building-engine">3. Add prop resolver when building <code>Engine</code></a></h4>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut resolvers = Resolvers&lt;(), ()&gt;::new();
resolvers.insert(&quot;project_points&quot;.to_string, Box::new(resolve_projectpoints));

let engine = Engine&lt;(), ()&gt;::new(config, db)
    .with_resolvers(resolvers)
    .build()
<span class="boring">}
</span></code></pre></pre>
<h1><a class="header" href="#dynamic-relationships" id="dynamic-relationships">Dynamic Relationships</a></h1>
<p>Dynamic relationships are similiar to Dynamic Props. Instead of returning values contained in the database, Dynamic relationships allows values to be computed at request time. </p>
<h2><a class="header" href="#usage-2" id="usage-2">Usage</a></h2>
<h4><a class="header" href="#1-mark-rel-as-dynamic-by-setting-the-resolver-field" id="1-mark-rel-as-dynamic-by-setting-the-resolver-field">1. Mark rel as dynamic by setting the resolver field</a></h4>
<pre><code class="language-config">version: 1
model: 
 - name: Project
   props: []
   rels:
    - name: topcontributor
      nodes: [User]
      props: []
      resolver: project_topcontributor
</code></pre>
<h4><a class="header" href="#2-define-custom-logic-that-resolve-the-prop-value-1" id="2-define-custom-logic-that-resolve-the-prop-value-1">2. Define custom logic that resolve the prop value</a></h4>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn resolve_project_topcontributor(
    facade: ResolverFacade&lt;AppGlobalContext, ()&gt;
) -&gt; ExecutionResult {

    // compute ...
    let mut hm = HashMap::new();
    hm.insert(&quot;id&quot;.to_string(), Value::String(&quot;1234567890&quot;.to_string()));
    hm.insert(&quot;name&quot;.to_string(), Value::String(&quot;Joe&quot;.to_string()));

    let rel = facade.create_rel(&quot;1234567890&quot;, None, &amp;facade.create_node(&quot;User&quot;, &amp;hm));
    
    facade.resolve_scalar(rel)
}
<span class="boring">}
</span></code></pre></pre>
<h4><a class="header" href="#3-add-prop-resolver-when-building-engine-1" id="3-add-prop-resolver-when-building-engine-1">3. Add prop resolver when building <code>Engine</code></a></h4>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut resolvers = Resolvers&lt;(), ()&gt;::new();
resolvers.insert(&quot;project_topcontributor&quot;.to_string, Box::new(resolve_project_topcontributor));

let engine = Engine&lt;(), ()&gt;::new(config, db)
    .with_resolvers(resolvers)
    .build()
<span class="boring">}
</span></code></pre></pre>
<h1><a class="header" href="#global-context" id="global-context">Global Context</a></h1>
<p>Warpgrapher's GlobalContext feature enable the creation of global state that is accessible across multiple points within Warpgrapher's event hooks including inside function endpoints. The example below will demonstrate how to set a <code>tenant_id</code> variable in the global context that denotes under which account the app is running. The app also creates a defined endpoint that returns that value to the caller.</p>
<h2><a class="header" href="#usage-3" id="usage-3">Usage</a></h2>
<h4><a class="header" href="#1-define-globalcontext-struct" id="1-define-globalcontext-struct">1. Define GlobalContext struct</a></h4>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Clone, Debug, Sync, Send)]
struct AppGlobalContext {
    tenant_id: String
}
<span class="boring">}
</span></code></pre></pre>
<p>The struct must implement <code>Clone</code>, <code>Debug</code>, <code>Sync</code>, and <code>Send</code>.</p>
<h4><a class="header" href="#2-create-engine-with-globalcontext-type-parameter-and-option" id="2-create-engine-with-globalcontext-type-parameter-and-option">2. Create Engine with GlobalContext type parameter and option</a></h4>
<p>The GlobalContext type is specified in the first type parameter of <code>Engine</code>. </p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let global_ctx = AppGlobalContext {
    tenant_id: &quot;123456&quot;.to_string();
}

let engine: Engine&lt;AppGlobalContext, ()&gt; = Engine::new(config, db)
    .with_global_ctx(global_ctx)
    .build();
<span class="boring">}
</span></code></pre></pre>
<h4><a class="header" href="#3-use-globalcontext-in-a-resolver" id="3-use-globalcontext-in-a-resolver">3. Use GlobalContext in a resolver</a></h4>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn resolve(facade: ResolverFacade&lt;AppGlobalContext, ()&gt;) -&gt; ExecutionResult {
    let global_ctx = facade.global_context()?;

    // use global_ctx
}
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#full-example" id="full-example">Full Example</a></h2>
<p><code>main.rs</code></p>
<pre><pre class="playground"><code class="language-rust">use std::collections::HashMap;
use warpgrapher::{Engine, Config};
use warpgrapher::engine::databases::neo4j::Neo4jEndpoint;
use warpgrapher::engine::resolvers::{Resolvers, ResolverFacade, ExecutionResult};
use warpgrapher::GraphQLRequest;

static CONFIG : &amp;'static str = &quot;
version: 1
model:
  - name: User
    props:
      - name: email
        type: String
  - name: Team
    props:
      - name: name
        type: String
    rels:
      - name: users
        nodes: [User]
endpoints:
  - name: GetEnvironment
    class: Query
    input: null
    output: 
      type: String
&quot;;

#[derive(Clone, Debug)]
struct AppGlobalContext {
    tenant_id: String
}

fn resolve_get_environment(facade: ResolverFacade&lt;AppGlobalContext, ()&gt;) -&gt; ExecutionResult {
    let global_ctx = facade.global_context()?;
    facade.resolve_scalar(global_ctx.tenant_id.clone())
}

fn main() {

    // parse warpgrapher config
    let config = Config::from_string(CONFIG.to_string())
        .expect(&quot;Failed to parse CONFIG&quot;);

    // define database endpoint
    let db = Neo4jEndpoint::from_env().unwrap();

    // define global context
    let global_ctx = AppGlobalContext {
        tenant_id: &quot;123456&quot;.to_string()
    };

    // define resolvers
    let mut resolvers = Resolvers::&lt;AppGlobalContext, ()&gt;::new();
    resolvers.insert(&quot;GetEnvironment&quot;.to_string(), Box::new(resolve_get_environment));

    // create warpgrapher engine
    let engine: Engine&lt;AppGlobalContext, ()&gt; = Engine::new(config, db.pool().unwrap())
        .with_global_ctx(global_ctx)
        .with_resolvers(resolvers)
        .build()
        .expect(&quot;Failed to build engine&quot;);

    // execute query on `GetEnvironment` endpoint
    let request = GraphQLRequest::new(
        &quot;query {
            GetEnvironment
        }
        &quot;.to_string(),
        None,
        None
    );
    let metadata = HashMap::new();
    let result = engine.execute(request, metadata).unwrap();

    // verify result
    println!(&quot;result: {:#?}&quot;, result);
    assert_eq!(
        &quot;123456&quot;,
        result
        .get(&quot;data&quot;).unwrap()
        .get(&quot;GetEnvironment&quot;).unwrap()
        .as_str().unwrap(),
    );
}
</code></pre></pre>
<h1><a class="header" href="#request-context" id="request-context">Request Context</a></h1>
<p>Warpgrapher Request Contexts enables the creation of mutable state through the lifecycle of a request including extensions hooks and resolvers.</p>
<h2><a class="header" href="#usage-4" id="usage-4">Usage</a></h2>
<h4><a class="header" href="#1-define-requestcontext-struct" id="1-define-requestcontext-struct">1. Define RequestContext struct</a></h4>
<p>The request context must implement <code>Clone</code>, <code>Debug</code>, <code>Sync</code>, <code>Send</code>, and Warpgrapher <code>RequestContext</code>. </p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Clone, Debug)]
struct AppRequestContext {
    request_id: String
}

impl warpgrapher::engine::context::RequestContext for AppRequestContext {
    fn new() -&gt; AppRequestContext {

        // initialize context ...

        AppRequestContext {
            request_id
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<h4><a class="header" href="#2-create-engine-with-requestcontext-type-parameter" id="2-create-engine-with-requestcontext-type-parameter">2. Create Engine with RequestContext type parameter</a></h4>
<p>The RequestContext is specified in the second type paramter of <code>Engine</code>. </p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let engine: Engine&lt;(), AppRequestContext&gt; = Engine::new(config, db)
    .build();
<span class="boring">}
</span></code></pre></pre>
<h4><a class="header" href="#3-access-context-inside-resolver" id="3-access-context-inside-resolver">3. Access Context inside resolver</a></h4>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn resolve(facade: ResolverFacade&lt;(), AppRequestContext&gt;) -&gt; ExecutionResult {
    let request_ctx = facade.request_context()?;

    // use request_ctx
}
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#full-example-1" id="full-example-1">Full Example</a></h2>
<pre><pre class="playground"><code class="language-rust">use std::collections::HashMap;
use warpgrapher::{Engine, Config};
use warpgrapher::engine::databases::neo4j::Neo4jEndpoint;
use warpgrapher::engine::resolvers::{Resolvers, ResolverFacade, ExecutionResult};
use warpgrapher::GraphQLRequest;

#[derive(Clone, Debug)]
struct AppRequestContext {
    request_id: String
}

impl warpgrapher::engine::context::RequestContext for AppRequestContext {
    fn new() -&gt; AppRequestContext {

        // generate a random id
        let request_id = &quot;12345678901234567890&quot;.to_string();

        AppRequestContext {
            request_id
        }
    }
}

/// This function will return the randomly generated request id
fn resolve_request_debug(context: ResolverFacade&lt;(), AppRequestContext&gt;) -&gt; ExecutionResult {
    let request_ctx = context.request_context()?;
    context.resolve_scalar(request_ctx.request_id.clone())
}

static CONFIG : &amp;'static str = &quot;
version: 1
model: []
endpoints:
  - name: RequestDebug
    class: Query
    input: null
    output: 
      type: String
&quot;;

fn main() {

    // parse warpgrapher config
    let config = Config::from_string(CONFIG.to_string())
        .expect(&quot;Failed to parse CONFIG&quot;);

    // define database endpoint
    let db = Neo4jEndpoint::from_env().unwrap();

    // define resolvers
    let mut resolvers = Resolvers::&lt;(), AppRequestContext&gt;::new();
    resolvers.insert(&quot;RequestDebug&quot;.to_string(), Box::new(resolve_request_debug));

    // create warpgrapher engine
    let engine: Engine&lt;(), AppRequestContext&gt; = Engine::new(config, db.pool().unwrap())
        .with_resolvers(resolvers)
        .build()
        .expect(&quot;Failed to build engine&quot;);

    // execute query on `GetEnvironment` endpoint
    let request = GraphQLRequest::new(
        &quot;query {
            RequestDebug
        }
        &quot;.to_string(),
        None,
        None
    );
    let metadata = HashMap::new();
    let result = engine.execute(request, metadata).unwrap();

    // verify result
    println!(&quot;result: {:#?}&quot;, result);
    assert_eq!(
        &quot;12345678901234567890&quot;,
        result
        .get(&quot;data&quot;).unwrap()
        .get(&quot;RequestDebug&quot;).unwrap()
        .as_str().unwrap(),
    );
}
</code></pre></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                

                
            </nav>

        </div>

        

        

        

        
        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        
        
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
        
        

    </body>
</html>
